from shapely.geometry import Point

from GeoDataFrameAux import GeoPolyDataFrameBuilder
from RoadGraph import StdRoadGraph
from RoadGraph.StdColNames import *
import geopandas as gpd
import pandas as pd
from operator import itemgetter
import random

class VulnerabilityAnalyser:

    def __init__(self, road_graph: StdRoadGraph):
        self.graph = road_graph

    def vulnerability_between_two_sites(self, source_site: str, target_site: str, key_sites: gpd.GeoDataFrame,
                                        key_sites_col, deactivation: int = 1, dimension_km: float = 5,
                                        iterations: int = 100):

        #Assign nearest nodes to source and target sites
        sites = key_sites.loc[key_sites[key_sites_col].isin([source_site, target_site])].copy()
        sites = self.assign_key_sites_to_nearest_nodes(sites)

        #Obtain list of nodes forming shortest path between source_site and target_site (using nearest nodes)
        source_node = sites.loc[sites[key_sites_col] == source_site, 'nearest_node'].values[0]
        target_node = sites.loc[sites[key_sites_col] == target_site, 'nearest_node'].values[0]
        shortest_path_nodes, shortest_time_base, base_edges_gdf, base_nodes_gdf = \
            self.graph.shortest_path_between_nodes(source_node, target_node, get_gdfs=True)

        #Filter grid by nodes that form the shortest path
        grid = self.generate_square_grid(dimension_km)
        shortest_path_nodes_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(shortest_path_nodes)]
        grid = self.filter_grid_by_nodes(grid, shortest_path_nodes_gdf)
        grid = self.filter_grid_by_key_sites(grid, sites)
        #Randomly select 'deactivation' squares from grid to deactivate
        grid_ids = grid.index.tolist()
        deactivation_square = grid.loc[random.choice(grid_ids), :]

        min_resilience_index = 1.0
        vulnerable_square = None
        vulnerable_path_nodes = shortest_path_nodes

        for i in range(iterations):
            print(i)
            resilience_index, curr_time, curr_path = self.calculate_resilience(source_node, target_node,
                                                                               deactivation_square, shortest_time_base)
            if resilience_index < min_resilience_index:
                min_resilience_index = resilience_index
                vulnerable_square = deactivation_square
                vulnerable_path_nodes = curr_path

            deactivation_square = grid.loc[random.choice(grid_ids), :]

        vulnerable_edges_gdf, vulnerable_nodes_gdf = self.graph.convert_path_to_gdfs(vulnerable_path_nodes)
        vulnerable_square = gpd.GeoDataFrame(vulnerable_square.to_frame().T, geometry='geometry')
        vulnerable_square.reset_index(drop=True, inplace=True)

        return self._package_resilience_results(base_nodes_gdf, base_edges_gdf, vulnerable_nodes_gdf,
                                                vulnerable_edges_gdf, min_resilience_index, vulnerable_square)

    def calculate_resilience(self, source_node, target_node, deactivation_polygon, shortest_time_base):

        within_grid = self.graph.nodes[STD_GEOMETRY].apply(lambda x: x.within(deactivation_polygon[STD_GEOMETRY]))
        nodes_within_grid = self.graph.nodes.loc[within_grid == True, STD_NODE_ID].tolist()
        self.deactivate_edges_between_nodes(nodes_within_grid)
        shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
        self.activate_edges_between_nodes(nodes_within_grid)
        resilience_index = shortest_time_base / shortest_time

        return resilience_index, shortest_time, shortest_path

    def _package_resilience_results(self, base_nodes_gdf, base_edges_gdf, vuln_nodes_gdf, vuln_edges_gdf,
                                    resilience_index, deactivation_square):
        results = {'base': [base_nodes_gdf, base_edges_gdf],
                   'least_resilient': [vuln_nodes_gdf, vuln_edges_gdf],
                   'resilience_index': resilience_index,
                   'grid_reference': deactivation_square}

        return results

    def generate_square_grid(self, dimension_km: float) -> gpd.GeoDataFrame:
        """
        Generates a square grid covering the total bounds of the edges of the road graph
        :param dimension_km: Dimension (width and height) of the square
        :return: GeoDataframe object containing the squares that form the grid
        """
        edges = self.graph.edges
        bounds = list(edges.total_bounds)
        minx, miny, maxx, maxy = bounds[0], bounds[1], bounds[2], bounds[3]
        size_m = dimension_km * 1000
        y = miny
        gdf = gpd.GeoDataFrame()

        while y < maxy:
            x = minx
            while x < maxx:
                coordinates = [(x, y), (x, y + size_m), (x + size_m, y + size_m), (x + size_m, y)]
                polygon = GeoPolyDataFrameBuilder().build_geo_frame(coordinates, 'epsg:27700')
                gdf = pd.concat([gdf, polygon])
                x += size_m
            y += size_m

        gdf.reset_index(drop=True, inplace=True)
        return gdf

    def filter_grid_by_nodes(self, grid: gpd.GeoDataFrame, nodes: gpd.GeoDataFrame=None) -> gpd.GeoDataFrame:
        """
        Removes squares from the grid that does not contain any nodes
        :param grid: Grid GeoDataFrame
        :param nodes: nodes geodataframe, is left as None then stdRoadGraph's nodes will be used instead.
        :return: Grid GeoDataFrame with only squares that contain nodes
        """

        if nodes is None:
            nodes = self.graph.nodes[STD_GEOMETRY].tolist()
        else:
            nodes = nodes[STD_GEOMETRY].tolist()

        contains_node = grid[STD_GEOMETRY].apply(lambda x: any(x.contains(node) for node in nodes))
        grid.drop(index=contains_node[contains_node == False].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def filter_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes key site points that are not within the bounds of grid
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: key_sites GeoDataFrame with only points residing within the grid
        """
        squares = grid[STD_GEOMETRY].tolist()
        within_square = key_sites[STD_GEOMETRY].apply(lambda x: any(x.within(square) for square in squares))
        key_sites.drop(index=within_square[within_square == False].index, inplace=True)
        key_sites.reset_index(drop=True, inplace=True)
        return key_sites

    def filter_grid_by_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes squares of the grid that contains a key site
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: grids geoDataFrame that do not have any key site points contained within it
        """
        key_sites = key_sites[STD_GEOMETRY].tolist()
        contains_key_site = grid[STD_GEOMETRY].apply(lambda x: any(x.contains(key_site) for key_site in key_sites))
        grid.drop(index=contains_key_site[contains_key_site == True].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def _nearest_node(self, point: Point) -> str:
        """
        Returns the nearest node to point
        :param point: point as Shapely.Point
        :return: Node Id of nearest node
        """

        nodes = self.graph.nodes[STD_GEOMETRY].tolist()
        min_index = min(enumerate([point.distance(node) for node in nodes]), key=itemgetter(1))[0]
        return self.graph.nodes.loc[min_index, STD_NODE_ID]

    def assign_key_sites_to_nearest_nodes(self, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Sets up new column in key_site GeoDataFrame stipulating the nearest node at each key site
        :param key_sites: GeoDataFrame of the key sites.
        :return: Updated key sites containing the nearest node per key site.
        """
        key_sites['nearest_node'] = key_sites[STD_GEOMETRY].apply(self._nearest_node)

        for index, key_site in key_sites.iterrows():
            nearest_node_id = key_site['nearest_node']
            key_sites.loc[key_sites['nearest_node'] == nearest_node_id, STD_GEOMETRY] = \
                self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == nearest_node_id, STD_GEOMETRY].values[0]
        return key_sites

    def deactivate_edges_between_nodes(self, nodes_within_grid: list):
        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                self.graph.set_road_closure(node, neighbour)
                self.graph.set_road_closure(neighbour, node)

    def activate_edges_between_nodes(self, nodes_within_grid: list):

        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                self.graph.remove_road_closure(node, neighbour)
                self.graph.remove_road_closure(neighbour, node)

