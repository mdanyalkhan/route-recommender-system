from shapely.geometry import Point

from GeoDataFrameAux import GeoPolyDataFrameBuilder
from RoadGraph import StdRoadGraph
from RoadGraph.StdColNames import *
import geopandas as gpd
import pandas as pd
import numpy as np
from operator import itemgetter
import random

from src.utilities.aux_func import parent_directory_at_level
directory = parent_directory_at_level(__file__, 4) + "/Working/Operational_Data/testing/vulnerability"


class VulnerabilityAnalyser:

    def __init__(self, road_graph: StdRoadGraph):
        self.graph = road_graph
        self.NULL_VAL = 5.0

    def vulnerability_between_all_sites(self, key_sites: gpd.GeoDataFrame, key_site_col: str, dimension_km: float = 1.0,
                                        deactivation_no: int = 5, iterations: int = 100):

        #Create grid of the network
        grid = self.generate_square_grid(dimension_km)
        grid = self.filter_grid_by_nodes(grid, self.graph.nodes)

        #Filter list of key sites to those that fit within the grid of the network
        sites_filtered = self.filter_key_sites(grid, key_sites)

        #Assign nearest nodes to each key site
        sites_filtered = self.assign_key_sites_to_nearest_nodes(sites_filtered)

        #For pair of sites calculate the shortest paths, and record the nodes that form these shortest paths.
        stb_matrix, spb_matrix, nodes_shortest_path = self._shortest_paths_all_sites(sites_filtered, key_site_col)
        #Filter the grid to these nodes only.
        nodes_shortest_path_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(nodes_shortest_path)]
        grid = self.filter_grid_by_nodes(grid, nodes_shortest_path_gdf)
        grid = self.filter_grid_by_key_sites(grid, sites_filtered)

        #Select grid squares at random, and calculate the shortest path for each pair of sites.
        grid_ids = grid.index.tolist()
        deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]
        mean_res = []
        for i in range(iterations):
            squares = deactivation_square[STD_GEOMETRY].tolist()
            within_grid = nodes_shortest_path_gdf[STD_GEOMETRY].apply(lambda x: any(x.within(square) for square in squares))
            nodes_within_grid = nodes_shortest_path_gdf.loc[within_grid == True, STD_NODE_ID].tolist()
            res_matrix = self.resilience_all_sites(sites_filtered, key_site_col, stb_matrix, spb_matrix,
                                                   nodes_within_grid)
            sum_res = np.sum(res_matrix, where= res_matrix != self.NULL_VAL)
            mean_res.append(sum_res/(len(key_sites)*len(key_sites) - len(key_sites)))
            deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]
        #Generate the mean and its standard deviation
        #Return the grid squares that produce the smallest mean resilience matrix
        print(min(mean_res))
        return mean_res

    def _shortest_paths_all_sites(self, key_sites: gpd.GeoDataFrame, key_sites_col_name: str):

        site_names = key_sites[key_sites_col_name].tolist()
        shortest_time_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        nodes_in_shortest_paths = []
        paths_matrix = []

        for row in range(len(shortest_time_matrix)):
            print(f'row {row}')
            list_of_paths = []
            source_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[row]]['nearest_node'].values[0]
            for col in range(len(shortest_time_matrix)):
                if col != row:
                    target_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[col]]['nearest_node'].values[0]
                    shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
                    shortest_time_matrix[row][col] = shortest_time
                    nodes_in_shortest_paths.extend(shortest_path)
                    list_of_paths.append(shortest_path)
                else:
                    list_of_paths.append([])

            paths_matrix.append(list_of_paths)

        nodes_in_shortest_paths = list(set(nodes_in_shortest_paths))

        return shortest_time_matrix, paths_matrix, nodes_in_shortest_paths

    def resilience_all_sites(self, key_sites: gpd.GeoDataFrame, key_sites_col_name: str, base_shortest_times: np.ndarray,
                             base_shortest_paths: list, nodes_within_grid: list):

        site_names = key_sites[key_sites_col_name].tolist()
        resilience_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        graph = self.graph

        for row in range(len(resilience_matrix)):
            source_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[row]]['nearest_node'].values[0]
            for col in range(len(resilience_matrix)):
                if col != row and any(item in nodes_within_grid for item in base_shortest_paths[row][col]):
                    target_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[col]]['nearest_node'].values[0]
                    self.deactivate_edges_between_nodes(nodes_within_grid)
                    shortest_path, shortest_time = graph.shortest_path_between_nodes(source_node, target_node)
                    self.activate_edges_between_nodes(nodes_within_grid)
                    resilience_matrix[row][col] = base_shortest_times[row][col]/shortest_time
                elif col == row:
                    resilience_matrix[row][col] = self.NULL_VAL
                else:
                    resilience_matrix[row][col] = 1.0

        return resilience_matrix

    def vulnerability_between_two_sites(self, source_site: str, target_site: str, key_sites: gpd.GeoDataFrame,
                                        key_sites_col, deactivation_no: int = 1, dimension_km: float = 1.0,
                                        iterations: int = 100) -> dict:
        """
        Performs a vulnerability analysis between two key sites by  blocking access to  a number of nodes randomly
        over a number of iterations through a grid-based approach.
        For each iteration, the resilience index is calculated and the set of grids that correspond to the smallest
        resilience index is returned.

        :param source_site: First of the pair of key sites
        :param target_site: Second of the pair of key sites
        :param key_sites: List of key sites
        :param key_sites_col: The column name containing the identity of the key sites
        :param deactivation_no: Number of grid squares to simultaneously select for deactivation of nodes per iteration.
        :param dimension_km: Size of the grid squares in km
        :param iterations: Number of iterations to run the analysis for
        :return: A dictionary of results containing: nodes and edges gdf of base shortest path, nodes and edges of
        the shortest path corresponding to the smallest resilience index, the smallest resilience index, and the set
        of grid squares corresponding to the smallest resilience index.
        """
        #Assign nearest nodes to source and target sites
        sites = key_sites.loc[key_sites[key_sites_col].isin([source_site, target_site])].copy()
        sites = self.assign_key_sites_to_nearest_nodes(sites)

        #Obtain list of nodes forming shortest path between source_site and target_site (using nearest nodes)
        source_node = sites.loc[sites[key_sites_col] == source_site, 'nearest_node'].values[0]
        target_node = sites.loc[sites[key_sites_col] == target_site, 'nearest_node'].values[0]
        shortest_path_nodes, shortest_time_base, base_edges_gdf, base_nodes_gdf = \
            self.graph.shortest_path_between_nodes(source_node, target_node, get_gdfs=True)

        #Filter grid by nodes that form the shortest path
        grid = self.generate_square_grid(dimension_km)
        shortest_path_nodes_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(shortest_path_nodes)]
        grid = self.filter_grid_by_nodes(grid, shortest_path_nodes_gdf)
        grid = self.filter_grid_by_key_sites(grid, sites)

        #Randomly select 'deactivation' squares from grid to deactivate
        grid_ids = grid.index.tolist()
        deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]

        min_resilience_index = 1.0
        vulnerable_square = None
        vulnerable_path_nodes = shortest_path_nodes

        for i in range(iterations):
            resilience_index, curr_time, curr_path = self.calculate_resilience(source_node, target_node,
                                                                               deactivation_square, shortest_time_base)
            if resilience_index < min_resilience_index:
                min_resilience_index = resilience_index
                vulnerable_square = deactivation_square
                vulnerable_path_nodes = curr_path

            deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]

        vulnerable_edges_gdf, vulnerable_nodes_gdf = self.graph.convert_path_to_gdfs(vulnerable_path_nodes)
        vulnerable_square.reset_index(drop=True, inplace=True)

        return self._package_resilience_results(base_nodes_gdf, base_edges_gdf, vulnerable_nodes_gdf,
                                                vulnerable_edges_gdf, min_resilience_index, vulnerable_square)

    def calculate_resilience(self, source_node: str, target_node: str, deactivation_polygon: gpd.GeoDataFrame,
                             shortest_time_base: float) -> (float, float, list):
        """
        Calculates the resilience index (i.e. the the shortest_base_time/shortest_time_following_closure) based
        on the list of inputted deactivation_polygon and between a node pair
        :param source_node: First node of the node pair
        :param target_node: Second node of the node pair
        :param deactivation_polygon: a group of polygons which will deactivate all nodes residing within their
        boundaries
        :param shortest_time_base: The time of the shortest path between the source and target node
        :return: The resilience index, as well as the shortest time and path between corresponding to this
        resilience index
        """
        geoms = deactivation_polygon[STD_GEOMETRY].tolist()

        within_grid = self.graph.nodes[STD_GEOMETRY].apply(lambda x: any(x.within(geom) for geom in geoms))
        nodes_within_grid = self.graph.nodes.loc[within_grid == True, STD_NODE_ID].tolist()
        self.deactivate_edges_between_nodes(nodes_within_grid)
        shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
        self.activate_edges_between_nodes(nodes_within_grid)
        resilience_index = shortest_time_base / shortest_time

        return resilience_index, shortest_time, shortest_path

    def _package_resilience_results(self, base_nodes_gdf: gpd.GeoDataFrame, base_edges_gdf: gpd.GeoDataFrame,
                                    vuln_nodes_gdf: gpd.GeoDataFrame, vuln_edges_gdf: gpd.GeoDataFrame,
                                    resilience_index: float, deactivation_square: gpd.GeoDataFrame) -> dict:
        """
        Wrapper function that packages the results into a dictionary
        :param base_nodes_gdf: GeoDataFrame of the nodes that form the shortest path (without obstruction)
        :param base_edges_gdf: GeoDataFrame of the edges that form the shortest path (without obstruction)
        :param vuln_nodes_gdf: GeoDataFrame of the nodes that form the shortest path (with obstruction)
        :param vuln_edges_gdf: GeoDataFrame of the edges that form the shortest path (with obstruction)
        :param resilience_index: A measure of the increase in the time to the shortest path due to the obstruction
        :param deactivation_square: The set of grid squares that caused this obstruction
        :return: dictionary structure of the results
        """
        results = {'base': [base_nodes_gdf, base_edges_gdf],
                   'least_resilient': [vuln_nodes_gdf, vuln_edges_gdf],
                   'resilience_index': resilience_index,
                   'grid_reference': deactivation_square}

        return results

    def generate_square_grid(self, dimension_km: float) -> gpd.GeoDataFrame:
        """
        Generates a square grid covering the total bounds of the edges of the road graph
        :param dimension_km: Dimension (width and height) of the square
        :return: GeoDataframe object containing the squares that form the grid
        """
        edges = self.graph.edges
        bounds = list(edges.total_bounds)
        minx, miny, maxx, maxy = bounds[0], bounds[1], bounds[2], bounds[3]
        size_m = dimension_km * 1000
        y = miny
        gdf = gpd.GeoDataFrame()

        while y < maxy:
            x = minx
            while x < maxx:
                coordinates = [(x, y), (x, y + size_m), (x + size_m, y + size_m), (x + size_m, y)]
                polygon = GeoPolyDataFrameBuilder().build_geo_frame(coordinates, 'epsg:27700')
                gdf = pd.concat([gdf, polygon])
                x += size_m
            y += size_m

        gdf.reset_index(drop=True, inplace=True)
        return gdf

    def filter_grid_by_nodes(self, grid: gpd.GeoDataFrame, nodes: gpd.GeoDataFrame=None) -> gpd.GeoDataFrame:
        """
        Removes squares from the grid that does not contain any nodes
        :param grid: Grid GeoDataFrame
        :param nodes: nodes geodataframe, is left as None then stdRoadGraph's nodes will be used instead.
        :return: Grid GeoDataFrame with only squares that contain nodes
        """

        if nodes is None:
            nodes = self.graph.nodes[STD_GEOMETRY].tolist()
        else:
            nodes = nodes[STD_GEOMETRY].tolist()

        contains_node = grid[STD_GEOMETRY].apply(lambda x: any(x.contains(node) for node in nodes))
        grid.drop(index=contains_node[contains_node == False].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def filter_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes key site points that are not within the bounds of grid
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: key_sites GeoDataFrame with only points residing within the grid
        """
        squares = grid[STD_GEOMETRY].tolist()
        within_square = key_sites[STD_GEOMETRY].apply(lambda x: any(x.within(square) for square in squares))
        key_sites.drop(index=within_square[within_square == False].index, inplace=True)
        key_sites.reset_index(drop=True, inplace=True)
        return key_sites

    def filter_grid_by_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes squares of the grid that contains a key site
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: grids geoDataFrame that do not have any key site points contained within it
        """
        key_sites = key_sites[STD_GEOMETRY].tolist()
        contains_key_site = grid[STD_GEOMETRY].apply(lambda x: any(x.contains(key_site) for key_site in key_sites))
        grid.drop(index=contains_key_site[contains_key_site == True].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def _nearest_node(self, point: Point) -> str:
        """
        Returns the nearest node to point
        :param point: point as Shapely.Point
        :return: Node Id of nearest node
        """

        nodes = self.graph.nodes[STD_GEOMETRY].tolist()
        min_index = min(enumerate([point.distance(node) for node in nodes]), key=itemgetter(1))[0]
        return self.graph.nodes.loc[min_index, STD_NODE_ID]

    def assign_key_sites_to_nearest_nodes(self, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Sets up new column in key_site GeoDataFrame stipulating the nearest node at each key site
        :param key_sites: GeoDataFrame of the key sites.
        :return: Updated key sites containing the nearest node per key site.
        """
        key_sites['nearest_node'] = key_sites[STD_GEOMETRY].apply(self._nearest_node)

        for index, key_site in key_sites.iterrows():
            nearest_node_id = key_site['nearest_node']
            key_sites.loc[key_sites['nearest_node'] == nearest_node_id, STD_GEOMETRY] = \
                self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == nearest_node_id, STD_GEOMETRY].values[0]
        return key_sites

    def deactivate_edges_between_nodes(self, nodes_within_grid: list):
        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                self.graph.set_road_closure(node, neighbour)
                self.graph.set_road_closure(neighbour, node)

    def activate_edges_between_nodes(self, nodes_within_grid: list):

        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                self.graph.remove_road_closure(node, neighbour)
                self.graph.remove_road_closure(neighbour, node)

