from shapely.geometry import Point, Polygon

from GeoDataFrameAux import GeoPolyDataFrameBuilder
from RoadGraph import StdRoadGraph, create_file_path
from RoadGraph.StdColNames import *
import geopandas as gpd
import pandas as pd
import numpy as np
from operator import itemgetter
import random
import matplotlib.pyplot as plt

from src.utilities.aux_func import parent_directory_at_level

directory = parent_directory_at_level(__file__, 4) + "/Working/Operational_Data/testing/vulnerability"


class VulnerabilityAnalyser:

    def __init__(self, road_graph: StdRoadGraph):
        self.graph = road_graph
        self.NULL_VAL = 5.0

    def srn_vulnerability_two_sites(self, source_site: str, target_site: str, key_sites: gpd.GeoDataFrame,
                                    key_sites_col: str, out_path: str = None, cutoff: int = 10) -> dict:
        """
        Determines the critical set of nodes, with increasing number of nodes, that are part of the SRN that has
        the biggest impact on journey times between two sites.
        :param source_site: Name of the key site to start the journey from
        :param target_site: Name of the key site which is the destination
        :param key_sites: gdf of key sites located within the road network
        :param key_sites_col: Name of the column that contains the name of the key sites within key_sites
        :param out_path: Optional file path to save the results of the analysis
        :return: Dictionary of critical set of nodes (with increasing size) and their corresponding resiliency index,
        and the edges and nodes gdfs that form the shortest path as a result of the closure of the srn nodes.
        """
        # Assign nearest nodes to source and target sites
        sites = key_sites.loc[key_sites[key_sites_col].isin([source_site, target_site])].copy()
        sites = self.assign_key_sites_to_nearest_nodes(sites)
        # Obtain list of nodes forming shortest path between source_site and target_site (using nearest nodes)
        source_node = sites.loc[sites[key_sites_col] == source_site, 'nearest_node'].values[0]
        target_node = sites.loc[sites[key_sites_col] == target_site, 'nearest_node'].values[0]
        shortest_path_nodes, shortest_time_base, base_edges_gdf, base_nodes_gdf = \
            self.graph.shortest_path_between_nodes(source_node, target_node, get_gdfs=True)

        sel_nodes = []
        self._filter_nodes_to_srn_nodes(sel_nodes, shortest_path_nodes)
        res_list = [1., 1.]
        anchor = []
        res_dict = {}
        res_dict['no_nodes'] = [1., base_edges_gdf, base_nodes_gdf]
        curr_edges_gdf = base_edges_gdf
        curr_nodes_gdf = base_nodes_gdf
        count = 0
        while True:
            que = []
            # Add sets of indices
            for node in sel_nodes:
                if node not in anchor:
                    que += [anchor + [node]]

            if not que:
                break

            while que:
                nodes = que.pop()
                self.deactivate_edges_between_nodes(nodes, only_srn=True)
                path, time = self.graph.shortest_path_between_nodes(source_node, target_node)
                self.activate_edges_between_nodes(nodes)
                res = shortest_time_base / time

                if res == 0.0:
                    continue

                if res <= res_list[-1]:
                    res_list[-1] = res
                    anchor = nodes
                    curr_edges_gdf, curr_nodes_gdf = self.graph.convert_path_to_gdfs(path)

                self._filter_nodes_to_srn_nodes(sel_nodes, path)

            res_dict[tuple(anchor)] = [res_list[-1], curr_edges_gdf, curr_nodes_gdf]
            print(count)
            if count >= cutoff:
                break
            count += 1
            res_list += [res_list[-1]]

        if out_path:
            self._save_to_path(res_dict, out_path)

        plt.plot(range(len(res_list[:-1])), res_list[:-1])
        plt.show()
        return res_dict

    def _save_to_path(self, res_dict: dict, out_path: str):
        """
        Saves the contents of res_dict into out_path
        :param res_dict: dictionary containing the resiliency index, and the edges and nodes that form the shortest path
        as a result of the closure of the nodes specified in the key.
        :param out_path: Path to save the contents of res_dict
        """
        shortest_path = create_file_path(f"{out_path}/shortest_path")
        res_dict['no_nodes'][1].to_file(f"{shortest_path}/s_edges.shp")
        res_dict['no_nodes'][2].to_file(f"{shortest_path}/s_nodes.shp")

        no_of_nodes = 1
        for node_set in list(res_dict)[1:]:
            path_name = create_file_path(f"{out_path}/critical_{no_of_nodes}")
            with open(f"{path_name}/info.txt", 'w') as target:
                target.write(f"Node Set {node_set} - Resilience Index {res_dict[node_set][0]}")
            target.close()

            node_list = list(node_set)
            nodes_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(node_list)]
            nodes_gdf.to_file(f"{path_name}/critical_nodes.shp")

            res_dict[node_set][1].to_file(f"{path_name}/s_edges.shp")
            res_dict[node_set][2].to_file(f"{path_name}/s_nodes.shp")

            no_of_nodes += 1

    def _filter_nodes_to_srn_nodes(self, sel_nodes: list, shortest_path_nodes: list):
        """
        Adds in any new and unique nodes from shortest_path_nodes into the set sel_nodes provided the node is part
        of the srn.
        :param sel_nodes: Set of existing srn nodes
        :param shortest_path_nodes: list of nodes.
        """
        for i in range(1, len(shortest_path_nodes) - 1):
            prev_node = shortest_path_nodes[i - 1]
            node = shortest_path_nodes[i]
            next_node = shortest_path_nodes[i + 1]
            if node not in sel_nodes:
                if self.graph.net[node][next_node][STD_Nx_ATTR][STD_Nx_IS_SRN]:
                    sel_nodes.append(node)
                elif i == 1 and self.graph.net[prev_node][node][STD_Nx_ATTR][STD_Nx_IS_SRN]:
                    sel_nodes.append(node)

    def vulnerability_all_sites_by_node_pairs(self, key_sites: gpd.GeoDataFrame, key_site_col: str, node_pairs: list):

        key_sites = self.assign_key_sites_to_nearest_nodes(key_sites)
        stb_matrix, spb_matrix, nodes_shortest_path = self._shortest_paths_all_sites(key_sites, key_site_col)


        for from_node, to_node in node_pairs:
            self.graph.net.set_road_closure(from_node, to_node)

        site_names = key_sites[key_site_col].tolist()
        resilience_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        closure_nodes = [node for node_pair in node_pairs for node in node_pair]
        closure_nodes = list(set(closure_nodes))

        for row in range(len(resilience_matrix)):
            source_node = key_sites.loc[key_sites[key_site_col] == site_names[row]]['nearest_node'].values[0]
            for col in range(len(resilience_matrix)):
                if col != row and any(item in closure_nodes for item in spb_matrix[row][col]):
                    target_node = \
                        key_sites.loc[key_sites[key_site_col] == site_names[col]]['nearest_node'].values[0]

                    shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)

                    resilience_matrix[row][col] = stb_matrix[row][col] / shortest_time
                elif col == row:
                    resilience_matrix[row][col] = np.nan
                else:
                    resilience_matrix[row][col] = 1.0

        for from_node, to_node in node_pairs:
            self.graph.net.remove_road_closure(from_node, to_node)

        print(resilience_matrix)
        return resilience_matrix

    def grid_vulnerability_all_sites(self, key_sites: gpd.GeoDataFrame, key_site_col: str, dimension_km: float = 1.0,
                                     deactivation_no: int = 5, iterations: int = 100):
        """
        Generates and returns the lowest of the mean resilience values following random de-activation of nodes that are
        a part of at least one of the shortest paths between two sites located within the road map.

        :param key_sites: gdf of key sites
        :param key_site_col: Column name corresponding to the names of the key sites.
        :param dimension_km: The dimensions of the grid squares to be generated accross the road map.
        :param deactivation_no: Number of grid squares to deactivate for every iteration.
        :param iterations: Number of iterations to perform.
        :return: The lowest of the mean resilience values.
        """
        # Create grid of the network
        grid = self.generate_square_grid(dimension_km)
        grid = self.filter_grid_by_nodes(grid, self.graph.nodes)

        # Filter list of key sites to those that fit within the grid of the network
        sites_filtered = self.filter_key_sites(grid, key_sites)

        # Assign nearest nodes to each key site
        sites_filtered = self.assign_key_sites_to_nearest_nodes(sites_filtered)

        # For each pair of sites calculate the shortest paths, and record the nodes that form these shortest paths.
        stb_matrix, spb_matrix, nodes_shortest_path = self._shortest_paths_all_sites(sites_filtered, key_site_col)
        # Filter the grid to these nodes only.
        nodes_shortest_path_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(nodes_shortest_path)]
        grid = self.filter_grid_by_nodes(grid, nodes_shortest_path_gdf)
        grid = self.filter_grid_by_key_sites(grid, sites_filtered)

        # Select grid squares at random, and calculate the shortest path for each pair of sites.
        grid_ids = grid.index.tolist()
        deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]
        mean_res = []
        std_res = []
        for i in range(iterations):
            squares = deactivation_square[STD_GEOMETRY].tolist()
            within_grid = nodes_shortest_path_gdf[STD_GEOMETRY].apply(
                lambda x: any(x.within(square) for square in squares))
            nodes_within_grid = nodes_shortest_path_gdf.loc[within_grid == True, STD_NODE_ID].tolist()
            res_matrix = self.resilience_all_sites(sites_filtered, key_site_col, stb_matrix, spb_matrix,
                                                   nodes_within_grid)
            res_ravelled = np.delete(res_matrix.ravel(), np.where(res_matrix.ravel() == self.NULL_VAL))

            mean_res.append(np.mean(res_ravelled))
            std_res.append(np.std(res_ravelled))
            deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]
        # Generate the mean and its standard deviation
        # Return the grid squares that produce the smallest mean resilience matrix

        min_mean, min_index = min([(mean, index) for index, mean in enumerate(mean_res)])

        print(min_mean)
        print(std_res[int(min_index)])

        return mean_res

    def _shortest_paths_all_sites(self, key_sites: gpd.GeoDataFrame, key_sites_col_name: str):
        """
        Calculates and returns the shortest path times, distances, and set of nodes between every pair of key sites.

        :param key_sites: gdf of key sites
        :param key_site_col: Column name corresponding to the names of the key sites.
        :return: Numpy nd-array of shortest times between every pair of sites, a matrix of nodes that form the shortest
        path for every pair of sites, and a set of all nodes that form all of the shortest paths examined.
        """
        site_names = key_sites[key_sites_col_name].tolist()
        shortest_time_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        nodes_in_shortest_paths = []
        paths_matrix = []

        for row in range(len(shortest_time_matrix)):
            print(f'row {row}')
            list_of_paths = []
            source_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[row]]['nearest_node'].values[0]
            for col in range(len(shortest_time_matrix)):
                if col != row:
                    target_node = \
                        key_sites.loc[key_sites[key_sites_col_name] == site_names[col]]['nearest_node'].values[0]
                    shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
                    shortest_time_matrix[row][col] = shortest_time
                    nodes_in_shortest_paths.extend(shortest_path)
                    list_of_paths.append(shortest_path)
                else:
                    list_of_paths.append([])

            paths_matrix.append(list_of_paths)

        nodes_in_shortest_paths = list(set(nodes_in_shortest_paths))

        return shortest_time_matrix, paths_matrix, nodes_in_shortest_paths

    def resilience_all_sites(self, key_sites: gpd.GeoDataFrame, key_sites_col_name: str,
                             base_shortest_times: np.ndarray,
                             base_shortest_paths: list, closure_nodes: list):
        """
        Calculates the shortest time between all pair of sites within key_sites following the closure of specific
        edges associated with specific nodes that are within nodes_within_grid.

        :param key_sites: gdf of key sites within the road map
        :param key_site_col: Column name corresponding to the names of the key sites.
        :param base_shortest_times: Numpy nd-array of the original shortest times between all pair of sites.
        :param base_shortest_paths: Numpy nd-array of the nodes that form the shortest paths between all pair of sites.
        :param closure_nodes: Nodes within the series of grid squares set for de-activation.
        :return: a Numpy nd-array of the fractional increase in time to travel between each pair of site relative
        to the original time as a result of closure of edges associated with the nodes in nodes_within_grid
        """
        site_names = key_sites[key_sites_col_name].tolist()
        resilience_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        graph = self.graph
        self.deactivate_edges_between_nodes(closure_nodes)
        for row in range(len(resilience_matrix)):
            source_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[row]]['nearest_node'].values[0]
            for col in range(len(resilience_matrix)):
                if col != row and any(item in closure_nodes for item in base_shortest_paths[row][col]):
                    target_node = \
                        key_sites.loc[key_sites[key_sites_col_name] == site_names[col]]['nearest_node'].values[0]

                    shortest_path, shortest_time = graph.shortest_path_between_nodes(source_node, target_node)

                    resilience_matrix[row][col] = base_shortest_times[row][col] / shortest_time
                elif col == row:
                    resilience_matrix[row][col] = self.NULL_VAL
                else:
                    resilience_matrix[row][col] = 1.0
        self.activate_edges_between_nodes(closure_nodes)
        return resilience_matrix

    def grid_vulnerability_two_sites(self, source_site: str, target_site: str, key_sites: gpd.GeoDataFrame,
                                     key_sites_col, deactivation_no: int = 1, dimension_km: float = 1.0,
                                     iterations: int = 100) -> dict:
        """
        Performs a vulnerability analysis between two key sites by  blocking access to  a number of nodes randomly
        over a number of iterations through a grid-based approach.
        For each iteration, the resilience index is calculated and the set of grids that correspond to the smallest
        resilience index is returned.

        :param source_site: First of the pair of key sites
        :param target_site: Second of the pair of key sites
        :param key_sites: List of key sites
        :param key_sites_col: The column name containing the identity of the key sites
        :param deactivation_no: Number of grid squares to simultaneously select for deactivation of nodes per iteration.
        :param dimension_km: Size of the grid squares in km
        :param iterations: Number of iterations to run the analysis for
        :return: A dictionary of results containing: nodes and edges gdf of base shortest path, nodes and edges of
        the shortest path corresponding to the smallest resilience index, the smallest resilience index, and the set
        of grid squares corresponding to the smallest resilience index.
        """
        # Assign nearest nodes to source and target sites
        sites = key_sites.loc[key_sites[key_sites_col].isin([source_site, target_site])].copy()
        sites = self.assign_key_sites_to_nearest_nodes(sites)

        # Obtain list of nodes forming shortest path between source_site and target_site (using nearest nodes)
        source_node = sites.loc[sites[key_sites_col] == source_site, 'nearest_node'].values[0]
        target_node = sites.loc[sites[key_sites_col] == target_site, 'nearest_node'].values[0]
        shortest_path_nodes, shortest_time_base, base_edges_gdf, base_nodes_gdf = \
            self.graph.shortest_path_between_nodes(source_node, target_node, get_gdfs=True)

        # Filter grid by nodes that form the shortest path
        grid = self.generate_square_grid(dimension_km)
        shortest_path_nodes_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(shortest_path_nodes)]
        grid = self.filter_grid_by_nodes(grid, shortest_path_nodes_gdf)
        grid = self.filter_grid_by_key_sites(grid, sites)

        # Randomly select 'deactivation' squares from grid to deactivate
        grid_ids = grid.index.tolist()
        deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]

        min_resilience_index = 1.0
        vulnerable_square = None
        vulnerable_path_nodes = shortest_path_nodes

        for i in range(iterations):
            resilience_index, curr_time, curr_path = self.calculate_resilience(source_node, target_node,
                                                                               deactivation_square, shortest_time_base)
            if resilience_index < min_resilience_index:
                min_resilience_index = resilience_index
                vulnerable_square = deactivation_square
                vulnerable_path_nodes = curr_path

            deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]

        vulnerable_edges_gdf, vulnerable_nodes_gdf = self.graph.convert_path_to_gdfs(vulnerable_path_nodes)
        vulnerable_square.reset_index(drop=True, inplace=True)

        return self._package_resilience_results(base_nodes_gdf, base_edges_gdf, vulnerable_nodes_gdf,
                                                vulnerable_edges_gdf, min_resilience_index, vulnerable_square)

    def calculate_resilience(self, source_node: str, target_node: str, deactivation_polygon: gpd.GeoDataFrame,
                             shortest_time_base: float, reactivate_inplace: bool = True, only_srn: bool = False) \
            -> (float, float, list):
        """
        Calculates the resilience index (i.e. the the shortest_base_time/shortest_time_following_closure) based
        on the list of inputted deactivation_polygon and between a node pair
        :param source_node: First node of the node pair
        :param target_node: Second node of the node pair
        :param deactivation_polygon: a group of polygons which will deactivate all nodes residing within their
        boundaries
        :param shortest_time_base: The time of the shortest path between the source and target node
        :return: The resilience index, as well as the shortest time and path between corresponding to this
        resilience index
        """
        geoms = deactivation_polygon[STD_GEOMETRY].tolist()

        within_grid = self.graph.nodes[STD_GEOMETRY].apply(lambda x: any(x.intersects(geom) for geom in geoms))
        nodes_within_grid = self.graph.nodes.loc[within_grid == True, STD_NODE_ID].tolist()
        self.deactivate_edges_between_nodes(nodes_within_grid, only_srn=only_srn)
        shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
        if reactivate_inplace:
            self.activate_edges_between_nodes(nodes_within_grid)
        resilience_index = shortest_time_base / shortest_time

        return resilience_index, shortest_time, shortest_path

    def _package_resilience_results(self, base_nodes_gdf: gpd.GeoDataFrame, base_edges_gdf: gpd.GeoDataFrame,
                                    vuln_nodes_gdf: gpd.GeoDataFrame, vuln_edges_gdf: gpd.GeoDataFrame,
                                    resilience_index: float, deactivation_square: gpd.GeoDataFrame) -> dict:
        """
        Wrapper function that packages the results into a dictionary
        :param base_nodes_gdf: GeoDataFrame of the nodes that form the shortest path (without obstruction)
        :param base_edges_gdf: GeoDataFrame of the edges that form the shortest path (without obstruction)
        :param vuln_nodes_gdf: GeoDataFrame of the nodes that form the shortest path (with obstruction)
        :param vuln_edges_gdf: GeoDataFrame of the edges that form the shortest path (with obstruction)
        :param resilience_index: A measure of the increase in the time to the shortest path due to the obstruction
        :param deactivation_square: The set of grid squares that caused this obstruction
        :return: dictionary structure of the results
        """
        results = {'base': [base_nodes_gdf, base_edges_gdf],
                   'least_resilient': [vuln_nodes_gdf, vuln_edges_gdf],
                   'resilience_index': resilience_index,
                   'grid_reference': deactivation_square}

        return results

    def generate_square_grid(self, dimension_km: float) -> gpd.GeoDataFrame:
        """
        Generates a square grid covering the total bounds of the edges of the road graph
        :param dimension_km: Dimension (width and height) of the square
        :return: GeoDataframe object containing the squares that form the grid
        """
        edges = self.graph.edges
        bounds = list(edges.total_bounds)
        minx, miny, maxx, maxy = bounds[0], bounds[1], bounds[2], bounds[3]
        size_m = dimension_km * 1000
        y = miny
        gdf = gpd.GeoDataFrame()

        list_of_poly = {'id': [], 'geometry': []}
        id = 1
        while y < maxy:
            print('waasd')
            x = minx
            while x < maxx:
                coordinates = [(x, y), (x, y + size_m), (x + size_m, y + size_m), (x + size_m, y)]
                list_of_poly['id'].append(id)
                list_of_poly['geometry'].append(Polygon(coordinates))
                id += 1

                x += size_m
            y += size_m

        df = pd.DataFrame(list_of_poly)
        gdf = gpd.GeoDataFrame(df, geometry='geometry')
        gdf.crs = {'init': 'epsg:27700'}

        return gdf

    def filter_grid_by_nodes(self, grid: gpd.GeoDataFrame, nodes: gpd.GeoDataFrame = None) -> gpd.GeoDataFrame:
        """
        Removes squares from the grid that does not contain any nodes
        :param grid: Grid GeoDataFrame
        :param nodes: nodes geodataframe, is left as None then stdRoadGraph's nodes will be used instead.
        :return: Grid GeoDataFrame with only squares that contain nodes
        """

        if nodes is None:
            nodes = self.graph.nodes[STD_GEOMETRY].tolist()
        else:
            nodes = nodes[STD_GEOMETRY].tolist()

        contains_node = grid[STD_GEOMETRY].apply(lambda x: any(x.intersects(node) for node in nodes))
        grid.drop(index=contains_node[contains_node == False].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def filter_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes key site points that are not within the bounds of grid
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: key_sites GeoDataFrame with only points residing within the grid
        """
        squares = grid[STD_GEOMETRY].tolist()
        within_square = key_sites[STD_GEOMETRY].apply(lambda x: any(x.within(square) for square in squares))
        key_sites.drop(index=within_square[within_square == False].index, inplace=True)
        key_sites.reset_index(drop=True, inplace=True)
        return key_sites

    def filter_grid_by_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes squares of the grid that contains a key site
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: grids geoDataFrame that do not have any key site points contained within it
        """
        key_sites = key_sites[STD_GEOMETRY].tolist()
        contains_key_site = grid[STD_GEOMETRY].apply(lambda x: any(x.contains(key_site) for key_site in key_sites))
        grid.drop(index=contains_key_site[contains_key_site == True].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def _nearest_node(self, point: Point) -> str:
        """
        Returns the nearest node to point
        :param point: point as Shapely.Point
        :return: Node Id of nearest node
        """

        nodes = self.graph.nodes[STD_GEOMETRY].tolist()
        min_index = min(enumerate([point.distance(node) for node in nodes]), key=itemgetter(1))[0]
        return self.graph.nodes.loc[min_index, STD_NODE_ID]

    def assign_key_sites_to_nearest_nodes(self, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Sets up new column in key_site GeoDataFrame stipulating the nearest node at each key site
        :param key_sites: GeoDataFrame of the key sites.
        :return: Updated key sites containing the nearest node per key site.
        """
        key_sites['nearest_node'] = key_sites[STD_GEOMETRY].apply(self._nearest_node)

        for index, key_site in key_sites.iterrows():
            nearest_node_id = key_site['nearest_node']
            key_sites.loc[key_sites['nearest_node'] == nearest_node_id, STD_GEOMETRY] = \
                self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == nearest_node_id, STD_GEOMETRY].values[0]
        return key_sites

    def deactivate_edges_between_nodes(self, nodes_within_grid: list, only_srn: bool = False):
        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                if only_srn:
                    if self.graph.net[node][neighbour][STD_Nx_ATTR][STD_Nx_IS_SRN]:
                        self.graph.set_road_closure(node, neighbour)
                        self.graph.set_road_closure(neighbour, node)
                else:
                    self.graph.set_road_closure(node, neighbour)
                    self.graph.set_road_closure(neighbour, node)

    def activate_edges_between_nodes(self, nodes_within_grid: list):

        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                self.graph.remove_road_closure(node, neighbour)
                self.graph.remove_road_closure(neighbour, node)
