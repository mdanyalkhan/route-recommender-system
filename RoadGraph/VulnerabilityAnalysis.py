from RoadGraph.StdRoadGraph import StdRoadGraph
from RoadGraph.util import grid_for_shpfile, bounds_of_shpfile
from RoadGraph.StdColNames import *
import numpy as np


def deactivate_edges_between_nodes(nodes_within_grid: list, graph: StdRoadGraph) -> StdRoadGraph:
    for node in nodes_within_grid:
        neighbours = list(graph.net.successors(node))
        for neighbour in neighbours:
            graph.set_road_closure(node, neighbour)
            graph.set_road_closure(neighbour, node)

    return graph


def activate_edges_between_nodes(nodes_within_grid: list, graph: StdRoadGraph) -> StdRoadGraph:
    for node in nodes_within_grid:
        neighbours = list(graph.net.successors(node))
        for neighbour in neighbours:
            graph.remove_road_closure(node, neighbour)
            graph.remove_road_closure(neighbour, node)

    return graph


def calculate_shortest_paths_between_sites(graph: StdRoadGraph):
    grids = grid_for_shpfile(graph.edges, 5)
    bounds = bounds_of_shpfile(grids)
    within_bounds = graph.key_sites[STD_GEOMETRY].apply(lambda x: x.within(bounds.loc[0, STD_GEOMETRY]))
    sites_within_bounds = graph.key_sites.loc[within_bounds == True, :]
    site_names = sites_within_bounds['location_n'].values

    grids['delay_index'] = 1.0
    base_measure = len(site_names) * len(site_names) - len(site_names)
    base_shortest_time, nodes_in_shortest_paths, base_shortest_paths = shortest_time_matrices(graph, site_names)
    print(base_shortest_paths[0][0])
    for index, grid in grids.iterrows():
        print(f"Grid Index: {index}")
        sites_in_grid = sites_within_bounds[STD_GEOMETRY].apply(lambda x: grid[STD_GEOMETRY].contains(x))
        if np.all(sites_in_grid.values == False):
            within_grid = graph.nodes[STD_GEOMETRY].apply(lambda x: x.within(grid[STD_GEOMETRY]))

            if np.all(within_grid == False):
                continue
            nodes_within_grid = graph.nodes.loc[within_grid == True, STD_NODE_ID].tolist()

            if any(item in nodes_within_grid for item in nodes_in_shortest_paths):
                graph = deactivate_edges_between_nodes(nodes_within_grid, graph)
                shortest_time = shortest_time_matrices_2(graph, site_names, nodes_within_grid,
                                                         base_shortest_paths, base_shortest_time)

                graph = activate_edges_between_nodes(nodes_within_grid, graph)

                normalised_time = np.divide(base_shortest_time, shortest_time, out=np.zeros_like(shortest_time),
                                            where=shortest_time != 0)
                current_measure = np.sum(normalised_time) / base_measure

                print(normalised_time)
                print(current_measure)

                grids.at[index, 'delay_index'] = current_measure

    return grids

    # shortest_time = shortest_time_matrix(graph, site_names)
    #
    # return shortest_time


def shortest_time_matrices(graph, site_names):
    shortest_time_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
    nodes_in_shortest_paths = []
    paths_matrix = []
    for row in range(len(shortest_time_matrix)):
        list_of_paths = []
        print(row)
        source_node = graph.key_sites.loc[graph.key_sites['location_n'] == site_names[row]]['node'].values[0]
        for col in range(len(shortest_time_matrix)):
            if col != row:
                target_node = graph.key_sites.loc[graph.key_sites['location_n'] == site_names[col]]['node'].values[0]
                dist, paths = graph.dijkstra_with_weight(source_node, target_node)
                shortest_time = dist[target_node]
                shortest_path = paths[target_node]
                shortest_time_matrix[row][col] = shortest_time
                nodes_in_shortest_paths.extend(shortest_path)
                list_of_paths.append(shortest_path)
            else:
                list_of_paths.append([])

        paths_matrix.append(list_of_paths)
    nodes_in_shortest_paths = list(set(nodes_in_shortest_paths))
    return shortest_time_matrix, nodes_in_shortest_paths, paths_matrix

def shortest_time_matrices_2(graph, site_names, nodes_within_grid, paths_matrix, base_shortest_time_matrix):
    shortest_time_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)

    for row in range(len(shortest_time_matrix)):
        print(row)
        source_node = graph.key_sites.loc[graph.key_sites['location_n'] == site_names[row]]['node'].values[0]
        for col in range(len(shortest_time_matrix)):
            if col != row and any(item in nodes_within_grid for item in paths_matrix[row][col]):
                target_node = graph.key_sites.loc[graph.key_sites['location_n'] == site_names[col]]['node'].values[0]
                dist, _ = graph.dijkstra_with_weight(source_node, target_node)
                shortest_time = dist[target_node]
                shortest_time_matrix[row][col] = shortest_time
            else:
                shortest_time_matrix[row][col] = base_shortest_time_matrix[row][col]

    return shortest_time_matrix

