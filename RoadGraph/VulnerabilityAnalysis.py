from RoadGraph.StdRoadGraph import StdRoadGraph
from RoadGraph.util import grid_for_shpfile, bounds_of_shpfile
from RoadGraph.StdColNames import *
import numpy as np
import networkx as net

def deactivate_edges_between_nodes(nodes_within_grid: list, graph: StdRoadGraph) -> StdRoadGraph:

    for node in nodes_within_grid:
        neighbours = list(graph.net.successors(node))
        for neighbour in neighbours:
            graph.set_road_closure(node, neighbour)
            graph.set_road_closure(neighbour, node)

    return graph

def activate_edges_between_nodes(nodes_within_grid: list, graph: StdRoadGraph) -> StdRoadGraph:

    for node in nodes_within_grid:
        neighbours = list(graph.net.successors(node))
        for neighbour in neighbours:
            graph.remove_road_closure(node, neighbour)
            graph.remove_road_closure(neighbour, node)

    return graph

def calculate_shortest_paths_between_sites(graph: StdRoadGraph):
    grids = grid_for_shpfile(graph.edges, 5)
    bounds = bounds_of_shpfile(grids)
    within_bounds = graph.key_sites[STD_GEOMETRY].apply(lambda x: x.within(bounds.loc[0, STD_GEOMETRY]))
    sites_within_bounds = graph.key_sites.loc[within_bounds == True, :]
    site_names = sites_within_bounds['location_n'].values

    grids['delay_index'] = 1.0
    base_measure = len(site_names)*len(site_names) - len(site_names)
    base_shortest_time = shortest_time_matrix(graph, site_names)

    for index, grid in grids.iterrows():
        sites_in_grid = sites_within_bounds[STD_GEOMETRY].apply(lambda x: grid[STD_GEOMETRY].contains(x))
        if np.all(sites_in_grid.values == False):
            within_grid = graph.nodes[STD_GEOMETRY].apply(lambda x: x.within(grid[STD_GEOMETRY]))

            if np.all(within_grid == False):
                continue
            nodes_within_grid = graph.nodes.loc[within_grid == True, STD_NODE_ID].tolist()

            graph = deactivate_edges_between_nodes(nodes_within_grid, graph)
            shortest_time = shortest_time_matrix(graph, site_names)
            graph = activate_edges_between_nodes(nodes_within_grid, graph)

            normalised_time = np.divide(base_shortest_time, shortest_time, out=np.zeros_like(shortest_time),
                                        where=shortest_time != 0)
            current_measure = np.sum(normalised_time)/base_measure

            print(normalised_time)
            print(current_measure)

            grids.at[index, 'delay_index'] = current_measure

    return grids

    # shortest_time = shortest_time_matrix(graph, site_names)
    #
    # return shortest_time


def shortest_time_matrix(graph, site_names):
    shortest_time = np.zeros((len(site_names), len(site_names)), dtype=float)
    for row in range(len(shortest_time)):
        print(row)
        for col in range(len(shortest_time)):
            if col != row:
                shortest_time[row][col] = graph.shortest_path_between_key_sites(site_names[row], site_names[col],
                                                                                get_path=False, get_dist=True)
    return shortest_time
