from shapely.geometry import Point, Polygon

from GeoDataFrameAux import extract_list_of_coords_from_geom_object
from RoadGraph import StdRoadGraph, create_file_path
from RoadGraph.constants.StdColNames import *
from RoadGraph.constants.StdKeyWords import *
import geopandas as gpd
import pandas as pd
import numpy as np
import random
import matplotlib.pyplot as plt
import datetime
from scipy.spatial import cKDTree


from src.utilities.aux_func import parent_directory_at_level

directory = parent_directory_at_level(__file__, 4) + "/Working/Operational_Data/testing/vulnerability"

#Constants
SITE_PAIRS = 'site pairs'
RES_INDEX = 'resilience index'
JOURNEY_TIME = 'journey time'
DELAYED_JOURNEY_TIME = 'delayed journey time'
PERC_INC = 'delay'
SHORTEST_PATH = 'shortest path'
DELAYED_SHORTEST_PATH = 'delayed shortest path'
NEAREST_NODE = 'nearest_node'

class VulnerabilityAnalyser:

    def __init__(self, road_graph: StdRoadGraph, is_time_weighted=True, base_speed_limit_kph=STD_SPEED_BUILT_UP):
        self.kph_to_mps_factor = 1000.0 / 3600.0
        self.base_speed_limit = base_speed_limit_kph * self.kph_to_mps_factor
        self.is_time_weighted = is_time_weighted
        self.graph = road_graph
        self.NULL_VAL = 5.0

    def srn_vulnerability_two_sites_grid(self, key_sites: gpd.GeoDataFrame, key_sites_col: str,
                                         source_site, target_site, dimension_km: float = 1.0,
                                         cutoff: int = 10, out_path: str = None):

        grid = self.generate_square_grid(dimension_km)
        node_to_grid, grid_to_node = self.generate_node_grid_dict(grid)

        # Assign nearest nodes to source and target sites
        sites = key_sites.loc[key_sites[key_sites_col].isin([source_site, target_site])].copy()
        nearest_nodes = self._nearest_nodes_each_site(sites, key_sites_col, self.graph.nodes)

        source_coord = sites.loc[sites[key_sites_col]==source_site, STD_GEOMETRY].values[0]
        target_coord = sites.loc[sites[key_sites_col] == target_site, STD_GEOMETRY].values[0]

        # Obtain list of nodes forming shortest path between source_site and target_site (using nearest nodes)
        default_s_node = nearest_nodes[source_site]['nearest_nodes'].pop()
        default_s_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==default_s_node, STD_GEOMETRY].values[0]

        default_t_node = nearest_nodes[target_site]['nearest_nodes'].pop()
        default_t_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==default_t_node, STD_GEOMETRY].values[0]

        shortest_path_nodes, shortest_time_base, base_edges_gdf, base_nodes_gdf = \
            self.graph.shortest_path_between_nodes(default_s_node, default_t_node, get_gdfs=True)

        #Insert additional time to reach sites from/to nearest nodes.
        time_from_source = self._estimate_weight(source_coord, default_s_coord)
        time_to_target = self._estimate_weight(target_coord, default_t_coord)
        shortest_time_base = shortest_time_base + time_from_source + time_to_target

        sel_nodes = []
        self._filter_nodes_to_srn_nodes(sel_nodes, shortest_path_nodes)
        sel_grids = [node_to_grid[node] for node in sel_nodes]
        res_list = [1., 1.]
        anchor = []
        anchor_grid = []
        res_dict = {}
        res_dict['no_nodes'] = [1., base_edges_gdf, base_nodes_gdf]
        res_dict['grid'] = grid
        curr_edges_gdf = base_edges_gdf
        curr_nodes_gdf = base_nodes_gdf
        count = 0

        while True:
            #Keep track if the nearest nodes have changed
            cur_s_node = default_s_node
            cur_t_node = default_t_node
            que = []
            # Add sets of indices

            for sel_grid in sel_grids:
                if sel_grid not in anchor_grid:
                    # node_pool= [node for nodes in grid_to_node[sel_grid] for node in nodes]
                    que += [anchor + [sel_grid]]

            if not que:
                break

            while que:
                grids = que.pop()
                # Set current source and target nodes
                que_s_node = default_s_node
                que_t_node = default_t_node

                # initialise indices pertaining to nearest nodes dict
                nearest_s_ind = 0
                nearest_t_ind = 0

                nodes = [node for grid in grids for node in grid_to_node[grid]]
                self.deactivate_edges_between_nodes(nodes)
                time = np.inf
                while time == np.inf:
                    path, time = self.graph.shortest_path_between_nodes(que_s_node, que_t_node)
                    if time == np.inf:
                        print('time is infinite')
                        inf_node = self._find_inf_node(path)
                        inf_point = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==inf_node, STD_GEOMETRY].values[0]
                        if inf_point.distance(source_coord) < inf_point.distance(target_coord):
                            que_s_node = nearest_nodes[source_site]['nearest_nodes'][nearest_s_ind]
                            nearest_s_ind += 1
                        else:
                            que_t_node = nearest_nodes[target_site]['nearest_nodes'][nearest_t_ind]
                            nearest_t_ind += 1

                self.activate_edges_between_nodes(nodes)

                #Add in the time to travel between nearest node and each site
                que_s_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==que_s_node, STD_GEOMETRY].values[0]
                que_t_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==que_t_node, STD_GEOMETRY].values[0]
                time_from_source = self._estimate_weight(que_s_coord, source_coord)
                time_to_target = self._estimate_weight(que_t_coord, target_coord)

                time = time + time_from_source + time_to_target

                res = shortest_time_base / time

                if res == 0.0:
                    print('something went wrong')
                    exit()

                if res <= res_list[-1]:
                    res_list[-1] = res
                    anchor = grids
                    curr_edges_gdf, curr_nodes_gdf = self.graph.convert_path_to_gdfs(path)
                    cur_s_node = que_s_node
                    cur_t_node = que_t_node

                self._filter_nodes_to_srn_nodes(sel_nodes, path)
                sel_grids += [node_to_grid[node] for node in sel_nodes if node_to_grid[node] not in sel_grids]

            sel_grids = list(set(sel_grids))
            res_dict[tuple(anchor)] = [res_list[-1], curr_edges_gdf, curr_nodes_gdf]
            print(count)
            if count >= cutoff:
                break
            count += 1
            res_list += [res_list[-1]]

            if cur_s_node != default_s_node:
                print('running through nearest node changes')
                #Firstly pop nodes from nearest node list until the first element matches
                while nearest_nodes[source_site]['nearest_nodes'][0] != cur_s_node:
                    nearest_nodes[source_site]['nearest_nodes'].pop()

                #Finally pop where it matches and assign default_s_node to new nearest node.
                nearest_nodes[source_site]['nearest_nodes'].pop()
                default_s_node = cur_s_node

            if cur_t_node != default_t_node:
                print('running through nearest node changes')
                while nearest_nodes[target_site]['nearest_nodes'][0] != cur_t_node:
                    nearest_nodes[target_site]['nearest_nodes'].pop()

                if cur_t_node != default_t_node:
                    nearest_nodes[target_site]['nearest_nodes'].pop()
                    default_s_node = cur_s_node

        if out_path:
            self._save_to_path_grids(res_dict, grid, out_path)

        plt.plot(range(len(res_list[:-1])), res_list[:-1])
        plt.show()

        return res_dict

    def generate_node_grid_dict(self, grid):


        grid_centre = grid['geometry'].apply(lambda x: x.centroid.coords[0])
        x_coord = [coord[0] for coord in grid_centre.tolist()]
        y_coord = [coord[1] for coord in grid_centre.tolist()]
        centre_coords = np.dstack([x_coord, y_coord])[0]
        tree = cKDTree(centre_coords)

        node_to_grid = {}
        grid_to_node = {}

        node_id = []
        node_coords = []

        for _, point in self.graph.nodes.iterrows():
            node_coords.extend(extract_list_of_coords_from_geom_object(point['geometry']))
            node_id.append(point[STD_NODE_ID])
        node_x = [coord[0] for coord in node_coords]
        node_y = [coord[1] for coord in node_coords]
        node_coords = np.dstack([node_x, node_y])[0]
        dist, indices = tree.query(node_coords, k=1)
        i = 0

        for index in indices:
            node_to_grid[node_id[i]] = int(index)
            grid_to_node.setdefault(int(index), []).append(node_id[i])
            i += 1

        return node_to_grid, grid_to_node

    def srn_vulnerability_two_sites_nodes(self, key_sites: gpd.GeoDataFrame, key_sites_col: str,
                                          source_site: str, target_site: str, out_path: str = None,
                                          cutoff: int = 10) -> dict:
        """
        Determines the critical set of nodes, with increasing number of nodes, that are part of the SRN that has
        the biggest impact on journey times between two sites.
        :param source_site: Name of the key site to start the journey from
        :param target_site: Name of the key site which is the destination
        :param key_sites: gdf of key sites located within the road network
        :param key_sites_col: Name of the column that contains the name of the key sites within key_sites
        :param out_path: Optional file path to save the results of the analysis
        :return: Dictionary of critical set of nodes (with increasing size) and their corresponding resiliency index,
        and the edges and nodes gdfs that form the shortest path as a result of the closure of the srn nodes.
        """
        # Assign nearest nodes to source and target sites
        sites = key_sites.loc[key_sites[key_sites_col].isin([source_site, target_site])].copy()
        nearest_nodes = self._nearest_nodes_each_site(sites, key_sites_col, self.graph.nodes)

        source_coord = sites.loc[sites[key_sites_col]==source_site, STD_GEOMETRY].values[0]
        target_coord = sites.loc[sites[key_sites_col] == target_site, STD_GEOMETRY].values[0]

        # sites = self.assign_key_sites_to_nearest_nodes(sites, self.graph.nodes)

        # Obtain list of nodes forming shortest path between source_site and target_site (using nearest nodes)
        default_s_node = nearest_nodes[source_site]['nearest_nodes'].pop()
        default_s_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==default_s_node, STD_GEOMETRY].values[0]

        default_t_node = nearest_nodes[target_site]['nearest_nodes'].pop()
        default_t_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==default_t_node, STD_GEOMETRY].values[0]

        shortest_path_nodes, shortest_time_base, base_edges_gdf, base_nodes_gdf = \
            self.graph.shortest_path_between_nodes(default_s_node, default_t_node, get_gdfs=True)

        #Insert additional time to reach sites from/to nearest nodes.
        time_from_source = self._estimate_weight(source_coord, default_s_coord)
        time_to_target = self._estimate_weight(target_coord, default_t_coord)
        shortest_time_base = shortest_time_base + time_from_source + time_to_target

        sel_nodes = []
        self._filter_nodes_to_srn_nodes(sel_nodes, shortest_path_nodes)
        res_list = [1., 1.]
        anchor = []
        res_dict = {}
        res_dict['no_nodes'] = [1., base_edges_gdf, base_nodes_gdf]
        curr_edges_gdf = base_edges_gdf
        curr_nodes_gdf = base_nodes_gdf
        count = 0

        while True:
            #Keep track if the nearest nodes have changed
            cur_s_node = default_s_node
            cur_t_node = default_t_node
            que = []
            # Add sets of indices
            for node in sel_nodes:
                if node not in anchor:
                    que += [anchor + [node]]

            if not que:
                break

            while que:
                # Set current source and target nodes
                que_s_node = default_s_node
                que_t_node = default_t_node

                # initialise indices pertaining to nearest nodes dict
                nearest_s_ind = 0
                nearest_t_ind = 0

                nodes = que.pop()
                self.deactivate_edges_between_nodes(nodes, only_srn=True)
                time = np.inf
                while time == np.inf:
                    path, time = self.graph.shortest_path_between_nodes(que_s_node, que_t_node)
                    if time == np.inf:
                        print('time is infinite')
                        inf_node = self._find_inf_node(path)
                        inf_point = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==inf_node, STD_GEOMETRY].values[0]
                        if inf_point.distance(source_coord) < inf_point.distance(target_coord):
                            que_s_node = nearest_nodes[source_site]['nearest_nodes'][nearest_s_ind]
                            nearest_s_ind += 1
                        else:
                            que_t_node = nearest_nodes[target_site]['nearest_nodes'][nearest_t_ind]
                            nearest_t_ind += 1
                self.activate_edges_between_nodes(nodes)

                #Add in the time to travel between nearest node and each site
                que_s_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==que_s_node, STD_GEOMETRY].values[0]
                que_t_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID]==que_t_node, STD_GEOMETRY].values[0]
                time_from_source = self._estimate_weight(que_s_coord, source_coord)
                time_to_target = self._estimate_weight(que_t_coord, target_coord)

                time = time + time_from_source + time_to_target
                res = shortest_time_base / time

                if res == 0.0:
                    print('something has gone wrong')
                    exit()

                if res <= res_list[-1]:
                    res_list[-1] = res
                    anchor = nodes
                    curr_edges_gdf, curr_nodes_gdf = self.graph.convert_path_to_gdfs(path)
                    cur_s_node = que_s_node
                    cur_t_node = que_t_node

                self._filter_nodes_to_srn_nodes(sel_nodes, path)


            res_dict[tuple(anchor)] = [res_list[-1], curr_edges_gdf, curr_nodes_gdf]
            print(count)
            if count >= cutoff:
                break
            count += 1
            res_list += [res_list[-1]]

            if cur_s_node != default_s_node:
                print('running through nearest node changes')
                #Firstly pop nodes from nearest node list until the first element matches
                while nearest_nodes[source_site]['nearest_nodes'][0] != cur_s_node:
                    nearest_nodes[source_site]['nearest_nodes'].pop()

                #Finally pop where it matches and assign default_s_node to new nearest node.
                nearest_nodes[source_site]['nearest_nodes'].pop()
                default_s_node = cur_s_node

            if cur_t_node != default_t_node:
                print('running through nearest node changes')
                while nearest_nodes[target_site]['nearest_nodes'][0] != cur_t_node:
                    nearest_nodes[target_site]['nearest_nodes'].pop()

                if cur_t_node != default_t_node:
                    nearest_nodes[target_site]['nearest_nodes'].pop()
                    default_s_node = cur_s_node

        if out_path:
            self._save_to_path_nodes(res_dict, out_path)

        plt.plot(range(len(res_list[:-1])), res_list[:-1])
        plt.show()
        return res_dict

    def _save_to_path_nodes(self, res_dict: dict, out_path: str):
        """
        Saves the contents of res_dict into out_path (node version)
        :param res_dict: dictionary containing the resiliency index, and the edges and nodes that form the shortest path
        as a result of the closure of the nodes specified in the key.
        :param out_path: Path to save the contents of res_dict
        """
        shortest_path = create_file_path(f"{out_path}/shortest_path")
        res_dict['no_nodes'][1].to_file(f"{shortest_path}/s_edges.shp")
        res_dict['no_nodes'][2].to_file(f"{shortest_path}/s_nodes.shp")

        no_of_nodes = 1
        for node_set in list(res_dict)[1:]:
            path_name = create_file_path(f"{out_path}/critical_{no_of_nodes}")
            with open(f"{path_name}/info.txt", 'w') as target:
                target.write(f"Node Set {node_set} - Resilience Index {res_dict[node_set][0]}")

            node_list = list(node_set)
            nodes_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(node_list)]
            nodes_gdf.to_file(f"{path_name}/critical_nodes.shp")

            res_dict[node_set][1].to_file(f"{path_name}/s_edges.shp")
            res_dict[node_set][2].to_file(f"{path_name}/s_nodes.shp")

            no_of_nodes += 1

    def _save_to_path_grids(self, res_dict: dict, grids: gpd.GeoDataFrame, out_path: str):
        """
        Saves the contents of res_dict into out_path (grid version)
        :param res_dict: dictionary containing the resiliency index, and the edges and nodes that form the shortest path
        as a result of the closure of the nodes specified in the key.
        :param out_path: Path to save the contents of res_dict
        """

        shortest_path = create_file_path(f"{out_path}/shortest_path")
        res_dict['no_nodes'][1].to_file(f"{shortest_path}/s_edges.shp")
        res_dict['no_nodes'][2].to_file(f"{shortest_path}/s_nodes.shp")
        res_dict['grid'].to_file(f"{shortest_path}/grid.shp")
        no_of_grids = 1
        for grid_set in list(res_dict)[2:]:
            print(grid_set)
            path_name = create_file_path(f"{out_path}/critical_{no_of_grids}")
            with open(f"{path_name}/info.txt", 'w') as target:
                target.write(f"Grid Set {grid_set} - Resilience Index {res_dict[grid_set][0]}")

            grid_list = list(grid_set)
            grid_gdf = grids.loc[grid_list]
            grid_gdf.to_file(f"{path_name}/critical_grids.shp")

            res_dict[grid_set][1].to_file(f"{path_name}/s_edges.shp")
            res_dict[grid_set][2].to_file(f"{path_name}/s_nodes.shp")

            no_of_grids += 1

    def _filter_nodes_to_srn_nodes(self, sel_nodes: list, shortest_path_nodes: list):
        """
        Adds in any new and unique nodes from shortest_path_nodes into the set sel_nodes provided the node is part
        of the srn.
        :param sel_nodes: Set of existing srn nodes
        :param shortest_path_nodes: list of nodes.
        """
        for i in range(1, len(shortest_path_nodes) - 1):
            prev_node = shortest_path_nodes[i - 1]
            node = shortest_path_nodes[i]
            next_node = shortest_path_nodes[i + 1]
            if node not in sel_nodes:
                if self.graph.net[node][next_node][STD_Nx_ATTR][STD_Nx_IS_SRN]:
                    sel_nodes.append(node)
                elif i == 1 and self.graph.net[prev_node][node][STD_Nx_ATTR][STD_Nx_IS_SRN]:
                    sel_nodes.append(node)

    def vulnerability_all_sites_by_node_pairs(self, key_sites: gpd.GeoDataFrame, key_site_col: str, node_pairs: list):
        """
        Calculate journey times and delayed journey times between each pair of key sites based on proposed closure
        of edges between node pairs.

        :param key_sites: Geo Dataframe of key sites
        :param key_site_col: Column name of key sites
        :param node_pairs: List of node pair tuples, the connecting edges of which will be closed
        :return: Resilience dictionary containing the following:
                {'site pairs: <name of key sites pairs>,
                 'resilience index: <The impact of closure to journey time based on original journey time/new journey
                 time>,
                 'journey times': <Journey time in hh:min:s between the site pairs>,
                 'delayed journey times' <Journey time following proposed closure between site pairs>,
                 'percentage increase': <percentage increase in joruney time as a result of the road closure>,
                 'shortest path': <list of nodes that form the shortest path between two sites>,
                 'delayed shortest path': <list of nodes that formt the shortest path following road closures>}
        """
        closure_nodes = [node for node_pair in node_pairs for node in node_pair]
        closure_nodes = list(set(closure_nodes))
        closure_nodes_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(closure_nodes) == False]

        #Assign nearest node to each key site
        nearest_nodes = self._nearest_nodes_each_site(key_sites, key_site_col, closure_nodes_gdf)
        key_sites[NEAREST_NODE] = key_sites[key_site_col].apply(lambda x: nearest_nodes[x]['nearest_nodes'].pop())

        #Calculate original shortest paths between each site pair
        stb_matrix, spb_matrix, nodes_shortest_path = self._shortest_paths_all_sites(key_sites, key_site_col)

        #Set proposed road closures
        for from_node, to_node in node_pairs:
            self.graph.set_road_closure(from_node, to_node)

        #Initialise data structures to record journey times before and after road closures
        site_names = key_sites[key_site_col].tolist()
        resilience_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        resilience_dict = self._initialise_res_dict()

        for row in range(len(resilience_matrix)):
            print(f"row {row}")

            source_depot = site_names[row]
            source_node = key_sites.loc[key_sites[key_site_col] == source_depot][NEAREST_NODE].values[0]

            for col in range(len(resilience_matrix)):
                target_depot = site_names[col]
                target_node = \
                    key_sites.loc[key_sites[key_site_col] == target_depot][NEAREST_NODE].values[0]

                #Only calculate new journey time if site pairs are different and the nodes that form the original
                #the shortest path between the two sites are part of the proposed closures
                if col != row and any(item in closure_nodes for item in spb_matrix[row][col]):

                    shortest_time = np.inf

                    #Repeat journey time calculations until we recieve a shortest time that is not infinite
                    while shortest_time == np.inf:
                        shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
                        if shortest_time == np.inf:
                            # Choose new nearest node for one of the sites such that the shortest time is not longer
                            # infiinite
                            inf_node = self._find_inf_node(shortest_path)
                            source_node, target_node = self._reset_nearest_nodes(key_sites, key_site_col, nearest_nodes,
                                                                                 source_depot, target_depot, inf_node)

                    #Insert added journey time from depot to nearest nodes.
                    source_site_coord = key_sites.loc[key_sites[key_site_col] == source_depot, STD_GEOMETRY].values[0]
                    source_node_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == source_node,STD_GEOMETRY].values[0]
                    target_site_coord = key_sites.loc[key_sites[key_site_col] == target_depot, STD_GEOMETRY].values[0]
                    target_node_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == target_node, STD_GEOMETRY].values[0]
                    time_from_source = self._estimate_weight(source_site_coord, source_node_coord)
                    time_to_target = self._estimate_weight(target_site_coord, target_node_coord)
                    shortest_time = shortest_time + time_from_source + time_to_target

                    #Calculate resilience and perc increase
                    resilience = stb_matrix[row][col] / shortest_time
                    perc_inc = abs(shortest_time - stb_matrix[row][col]) / stb_matrix[row][col] * 100

                elif col == row:
                    resilience = np.nan
                    shortest_time = stb_matrix[row][col]
                    perc_inc = 0.0
                    resilience_matrix[row][col] = np.nan
                else:
                    resilience = 1.0
                    shortest_time = stb_matrix[row][col]
                    shortest_path = spb_matrix[row][col]
                    perc_inc = 0.0
                    resilience_matrix[row][col] = 1.0

                resilience_matrix[row][col] = resilience
                if row != col and f"{target_depot}_{source_depot}" not in resilience_dict[SITE_PAIRS] and \
                        f"{source_depot}_{target_depot}" not in resilience_dict[SITE_PAIRS]:
                    self._update_res_dict(col, perc_inc, resilience, resilience_dict, row, shortest_path, shortest_time,
                                          source_depot, spb_matrix, stb_matrix, target_depot)

        for from_node, to_node in node_pairs:
            self.graph.remove_road_closure(from_node, to_node)


        return resilience_matrix, resilience_dict

    def _update_res_dict(self, col: int, perc_inc: float, resilience: float, resilience_dict: dict, row: int,
                         shortest_path: list, shortest_time: float, source_depot: str, spb_matrix: list,
                         stb_matrix: np.ndarray, target_depot: str):
        """
        Helper function that updates resilience dictionary
        """
        resilience_dict[SITE_PAIRS].append(f"{source_depot}_{target_depot}")
        resilience_dict[RES_INDEX].append(resilience)
        resilience_dict[JOURNEY_TIME].append(datetime.timedelta(seconds=stb_matrix[row][col]))
        resilience_dict[DELAYED_JOURNEY_TIME].append(datetime.timedelta(seconds=shortest_time))
        resilience_dict[PERC_INC].append(perc_inc)
        resilience_dict[SHORTEST_PATH].append(spb_matrix[row][col])
        resilience_dict[DELAYED_SHORTEST_PATH].append(shortest_path)

    def _initialise_res_dict(self):
        """
        Helper function that initialises and returns a resilience dictionary
        :return: returns a resilience dictionary data structure
        """
        resilience_dict = {SITE_PAIRS: [],
                           RES_INDEX: [],
                           JOURNEY_TIME: [],
                           DELAYED_JOURNEY_TIME: [],
                           PERC_INC: [],
                           SHORTEST_PATH: [],
                           DELAYED_SHORTEST_PATH: []
                           }
        return resilience_dict

    def _find_inf_node(self, current_shortest_path: list) -> str:
        """
        Finds the node with the edge in the shortest path with inf weight
        :param current_shortest_path: list of nodes that forms the shortest path
        :return: Name of the node that has the edge with an inf weight
        """
        for i in range(len(current_shortest_path) - 1):
            from_node = current_shortest_path[i]
            to_node = current_shortest_path[i + 1]

            if self.graph.net[from_node][to_node][STD_Nx_WEIGHT] == np.inf:
                return from_node

    def _reset_nearest_nodes(self, key_sites: gpd.GeoDataFrame, key_col_name: str, nearest_nodes: dict,
                             source_site: str, target_site: str, inf_node: str) -> (str, str):
        """
        Replaces the 'nearest node' of one of the site pairs based on which site is closest to the node
        that caused the inf weight addition.
        :param key_sites: Geo Dataframe of the key sites
        :param key_col_name: column name of the key sites
        :param nearest_nodes: Dictionary of nearest nodes per key site
        :param source_site: Name of source site
        :param target_site: Name of target site
        :param inf_node: Node in shortest path with edge with weight inf
        :return: the nodes corresponding to the source and taget sites.
        """
        source_point = key_sites.loc[key_sites[key_col_name] == source_site][STD_GEOMETRY].values[0]
        target_point = key_sites.loc[key_sites[key_col_name] == target_site][STD_GEOMETRY].values[0]
        inf_point = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == inf_node][STD_GEOMETRY].values[0]

        if inf_point.distance(source_point) < inf_point.distance(target_point):
            new_source_node = nearest_nodes[source_site]['nearest_nodes'].pop()
            old_target_node = key_sites.loc[key_sites[key_col_name] == target_site][NEAREST_NODE].values[0]
            key_sites.at[key_sites[key_col_name] == source_site, NEAREST_NODE] = new_source_node

            return new_source_node, old_target_node
        else:
            new_target_node = nearest_nodes[target_site]['nearest_nodes'].pop()
            old_source_node = key_sites.loc[key_sites[key_col_name] == source_site][NEAREST_NODE].values[0]
            key_sites.at[key_sites[key_col_name] == target_site, NEAREST_NODE] = new_target_node

            return old_source_node, new_target_node

    def _find_next_nearest_node(self, key_sites, key_col_name, nearest_nodes, source_site, target_site, nearest_s_ind,
                                nearest_t_ind, inf_node):

        source_point = key_sites.loc[key_sites[key_col_name] == source_site][STD_GEOMETRY].values[0]
        target_point = key_sites.loc[key_sites[key_col_name] == target_site][STD_GEOMETRY].values[0]
        inf_point = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == inf_node][STD_GEOMETRY].values[0]

        if inf_point.distance(source_point) < inf_point.distance(target_point):
            new_source_node = nearest_nodes[source_site]['nearest_nodes'][nearest_s_ind]
            old_target_node = key_sites.loc[key_sites[key_col_name] == target_site][NEAREST_NODE].values[0]
            nearest_s_ind += 1
            return new_source_node, old_target_node, nearest_s_ind, nearest_t_ind
        else:
            new_target_node = nearest_nodes[target_site]['nearest_nodes'][nearest_t_ind]
            old_source_node = key_sites.loc[key_sites[key_col_name] == source_site][NEAREST_NODE].values[0]

            return old_source_node, new_target_node

    def grid_vulnerability_all_sites(self, key_sites: gpd.GeoDataFrame, key_site_col: str, dimension_km: float = 1.0,
                                     deactivation_no: int = 5, iterations: int = 100):
        """
        Generates and returns the lowest of the mean resilience values following random de-activation of nodes that are
        a part of at least one of the shortest paths between two sites located within the road map.

        :param key_sites: gdf of key sites
        :param key_site_col: Column name corresponding to the names of the key sites.
        :param dimension_km: The dimensions of the grid squares to be generated accross the road map.
        :param deactivation_no: Number of grid squares to deactivate for every iteration.
        :param iterations: Number of iterations to perform.
        :return: The lowest of the mean resilience values.
        """
        # Create grid of the network
        grid = self.generate_square_grid(dimension_km)
        grid = self.filter_grid_by_nodes(grid, self.graph.nodes)

        # Filter list of key sites to those that fit within the grid of the network
        sites_filtered = self.filter_key_sites(grid, key_sites)

        # Assign nearest nodes to each key site
        sites_filtered = self.assign_key_sites_to_nearest_nodes(sites_filtered, self.graph.nodes)

        # For each pair of sites calculate the shortest paths, and record the nodes that form these shortest paths.
        stb_matrix, spb_matrix, nodes_shortest_path = self._shortest_paths_all_sites(sites_filtered, key_site_col)
        # Filter the grid to these nodes only.
        nodes_shortest_path_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(nodes_shortest_path)]
        grid = self.filter_grid_by_nodes(grid, nodes_shortest_path_gdf)
        grid = self.filter_grid_by_key_sites(grid, sites_filtered)

        # Select grid squares at random, and calculate the shortest path for each pair of sites.
        grid_ids = grid.index.tolist()
        deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]
        mean_res = []
        std_res = []
        for i in range(iterations):
            squares = deactivation_square[STD_GEOMETRY].tolist()
            within_grid = nodes_shortest_path_gdf[STD_GEOMETRY].apply(
                lambda x: any(x.within(square) for square in squares))
            nodes_within_grid = nodes_shortest_path_gdf.loc[within_grid == True, STD_NODE_ID].tolist()
            res_matrix = self.resilience_all_sites(sites_filtered, key_site_col, stb_matrix, spb_matrix,
                                                   nodes_within_grid)
            res_ravelled = np.delete(res_matrix.ravel(), np.where(res_matrix.ravel() == self.NULL_VAL))

            mean_res.append(np.mean(res_ravelled))
            std_res.append(np.std(res_ravelled))
            deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]
        # Generate the mean and its standard deviation
        # Return the grid squares that produce the smallest mean resilience matrix

        min_mean, min_index = min([(mean, index) for index, mean in enumerate(mean_res)])

        print(min_mean)
        print(std_res[int(min_index)])

        return mean_res

    def _shortest_paths_all_sites(self, key_sites: gpd.GeoDataFrame, key_sites_col_name: str):
        """
        Calculates and returns the shortest path times, distances, and set of nodes between every pair of key sites.

        :param key_sites: gdf of key sites
        :param key_site_col: Column name corresponding to the names of the key sites.
        :return: Numpy nd-array of shortest times between every pair of sites, a matrix of nodes that form the shortest
        path for every pair of sites, and a set of all nodes that form all of the shortest paths examined.
        """
        site_names = key_sites[key_sites_col_name].tolist()
        shortest_time_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        nodes_in_shortest_paths = []
        paths_matrix = []

        for row in range(len(shortest_time_matrix)):
            list_of_paths = []
            source_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[row]][NEAREST_NODE].values[0]
            source_site_coord = key_sites.loc[key_sites[key_sites_col_name] == site_names[row], STD_GEOMETRY].values[0]
            source_node_coord = \
                self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == source_node, STD_GEOMETRY].values[0]
            weight_to_source_node = self._estimate_weight(source_site_coord, source_node_coord)

            for col in range(len(shortest_time_matrix)):
                if col != row:
                    target_node = \
                        key_sites.loc[key_sites[key_sites_col_name] == site_names[col]][NEAREST_NODE].values[0]
                    target_site_coord = \
                        key_sites.loc[key_sites[key_sites_col_name] == site_names[col], STD_GEOMETRY].values[0]
                    target_node_coord = \
                        self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == target_node, STD_GEOMETRY].values[0]
                    weight_from_target_node = self._estimate_weight(target_node_coord, target_site_coord)

                    shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
                    shortest_time_matrix[row][col] = shortest_time + weight_to_source_node + weight_from_target_node
                    nodes_in_shortest_paths.extend(shortest_path)
                    list_of_paths.append(shortest_path)
                else:
                    list_of_paths.append([])

            paths_matrix.append(list_of_paths)

        nodes_in_shortest_paths = list(set(nodes_in_shortest_paths))

        return shortest_time_matrix, paths_matrix, nodes_in_shortest_paths

    def resilience_all_sites(self, key_sites: gpd.GeoDataFrame, key_sites_col_name: str,
                             base_shortest_times: np.ndarray,
                             base_shortest_paths: list, closure_nodes: list):
        """
        Calculates the shortest time between all pair of sites within key_sites following the closure of specific
        edges associated with specific nodes that are within nodes_within_grid.

        :param key_sites: gdf of key sites within the road map
        :param key_site_col: Column name corresponding to the names of the key sites.
        :param base_shortest_times: Numpy nd-array of the original shortest times between all pair of sites.
        :param base_shortest_paths: Numpy nd-array of the nodes that form the shortest paths between all pair of sites.
        :param closure_nodes: Nodes within the series of grid squares set for de-activation.
        :return: a Numpy nd-array of the fractional increase in time to travel between each pair of site relative
        to the original time as a result of closure of edges associated with the nodes in nodes_within_grid
        """
        site_names = key_sites[key_sites_col_name].tolist()
        resilience_matrix = np.zeros((len(site_names), len(site_names)), dtype=float)
        graph = self.graph
        self.deactivate_edges_between_nodes(closure_nodes)
        for row in range(len(resilience_matrix)):
            source_node = key_sites.loc[key_sites[key_sites_col_name] == site_names[row]][NEAREST_NODE].values[0]
            source_site_coord = key_sites.loc[key_sites[key_sites_col_name] == site_names[row], STD_GEOMETRY]
            source_node_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == source_node, STD_GEOMETRY]
            weight_to_source_node = self._estimate_weight(source_site_coord, source_node_coord)

            for col in range(len(resilience_matrix)):
                if col != row and any(item in closure_nodes for item in base_shortest_paths[row][col]):
                    target_node = \
                        key_sites.loc[key_sites[key_sites_col_name] == site_names[col]][NEAREST_NODE].values[0]
                    target_site_coord = key_sites.loc[key_sites[key_sites_col_name] == site_names[col], STD_GEOMETRY]
                    target_node_coord = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == target_node, STD_GEOMETRY]
                    weight_from_target_node = self._estimate_weight(target_node_coord, target_site_coord)

                    shortest_path, shortest_time = graph.shortest_path_between_nodes(source_node, target_node)
                    shortest_time = shortest_time + weight_from_target_node + weight_to_source_node
                    resilience_matrix[row][col] = base_shortest_times[row][col] / shortest_time
                elif col == row:
                    resilience_matrix[row][col] = self.NULL_VAL
                else:
                    resilience_matrix[row][col] = 1.0
        self.activate_edges_between_nodes(closure_nodes)
        return resilience_matrix

    def _estimate_weight(self, a: Point, b: Point) -> float:
        """
        Calculates the weight between two points
        :param a: Point object
        :param b: Point object
        :return: Weight between two points, either as distance or time.
        """
        weight = a.distance(b)
        if self.is_time_weighted:
            weight = weight / self.base_speed_limit

        return weight

    def grid_vulnerability_two_sites(self, source_site: str, target_site: str, key_sites: gpd.GeoDataFrame,
                                     key_sites_col, deactivation_no: int = 1, dimension_km: float = 1.0,
                                     iterations: int = 100) -> dict:
        """
        Performs a vulnerability analysis between two key sites by  blocking access to  a number of nodes randomly
        over a number of iterations through a grid-based approach.
        For each iteration, the resilience index is calculated and the set of grids that correspond to the smallest
        resilience index is returned.

        :param source_site: First of the pair of key sites
        :param target_site: Second of the pair of key sites
        :param key_sites: List of key sites
        :param key_sites_col: The column name containing the identity of the key sites
        :param deactivation_no: Number of grid squares to simultaneously select for deactivation of nodes per iteration.
        :param dimension_km: Size of the grid squares in km
        :param iterations: Number of iterations to run the analysis for
        :return: A dictionary of results containing: nodes and edges gdf of base shortest path, nodes and edges of
        the shortest path corresponding to the smallest resilience index, the smallest resilience index, and the set
        of grid squares corresponding to the smallest resilience index.
        """
        # Assign nearest nodes to source and target sites
        sites = key_sites.loc[key_sites[key_sites_col].isin([source_site, target_site])].copy()
        sites = self.assign_key_sites_to_nearest_nodes(sites, self.graph.nodes)

        # Obtain list of nodes forming shortest path between source_site and target_site (using nearest nodes)
        source_node = sites.loc[sites[key_sites_col] == source_site, NEAREST_NODE].values[0]
        target_node = sites.loc[sites[key_sites_col] == target_site, NEAREST_NODE].values[0]
        shortest_path_nodes, shortest_time_base, base_edges_gdf, base_nodes_gdf = \
            self.graph.shortest_path_between_nodes(source_node, target_node, get_gdfs=True)

        # Filter grid by nodes that form the shortest path
        grid = self.generate_square_grid(dimension_km)
        shortest_path_nodes_gdf = self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID].isin(shortest_path_nodes)]
        grid = self.filter_grid_by_nodes(grid, shortest_path_nodes_gdf)
        grid = self.filter_grid_by_key_sites(grid, sites)

        # Randomly select 'deactivation' squares from grid to deactivate
        grid_ids = grid.index.tolist()
        deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]

        min_resilience_index = 1.0
        vulnerable_square = None
        vulnerable_path_nodes = shortest_path_nodes

        for i in range(iterations):
            resilience_index, curr_time, curr_path = self.calculate_resilience(source_node, target_node,
                                                                               deactivation_square, shortest_time_base)
            if resilience_index < min_resilience_index:
                min_resilience_index = resilience_index
                vulnerable_square = deactivation_square
                vulnerable_path_nodes = curr_path

            deactivation_square = grid.loc[random.sample(grid_ids, deactivation_no)]

        vulnerable_edges_gdf, vulnerable_nodes_gdf = self.graph.convert_path_to_gdfs(vulnerable_path_nodes)
        vulnerable_square.reset_index(drop=True, inplace=True)

        return self._package_resilience_results(base_nodes_gdf, base_edges_gdf, vulnerable_nodes_gdf,
                                                vulnerable_edges_gdf, min_resilience_index, vulnerable_square)

    def calculate_resilience(self, source_node: str, target_node: str, deactivation_polygon: gpd.GeoDataFrame,
                             shortest_time_base: float, reactivate_inplace: bool = True, only_srn: bool = False) \
            -> (float, float, list):
        """
        Calculates the resilience index (i.e. the the shortest_base_time/shortest_time_following_closure) based
        on the list of inputted deactivation_polygon and between a node pair
        :param source_node: First node of the node pair
        :param target_node: Second node of the node pair
        :param deactivation_polygon: a group of polygons which will deactivate all nodes residing within their
        boundaries
        :param shortest_time_base: The time of the shortest path between the source and target node
        :return: The resilience index, as well as the shortest time and path between corresponding to this
        resilience index
        """
        geoms = deactivation_polygon[STD_GEOMETRY].tolist()

        within_grid = self.graph.nodes[STD_GEOMETRY].apply(lambda x: any(x.intersects(geom) for geom in geoms))
        nodes_within_grid = self.graph.nodes.loc[within_grid == True, STD_NODE_ID].tolist()
        self.deactivate_edges_between_nodes(nodes_within_grid, only_srn=only_srn)
        shortest_path, shortest_time = self.graph.shortest_path_between_nodes(source_node, target_node)
        if reactivate_inplace:
            self.activate_edges_between_nodes(nodes_within_grid)
        resilience_index = shortest_time_base / shortest_time

        return resilience_index, shortest_time, shortest_path

    def _package_resilience_results(self, base_nodes_gdf: gpd.GeoDataFrame, base_edges_gdf: gpd.GeoDataFrame,
                                    vuln_nodes_gdf: gpd.GeoDataFrame, vuln_edges_gdf: gpd.GeoDataFrame,
                                    resilience_index: float, deactivation_square: gpd.GeoDataFrame) -> dict:
        """
        Wrapper function that packages the results into a dictionary
        :param base_nodes_gdf: GeoDataFrame of the nodes that form the shortest path (without obstruction)
        :param base_edges_gdf: GeoDataFrame of the edges that form the shortest path (without obstruction)
        :param vuln_nodes_gdf: GeoDataFrame of the nodes that form the shortest path (with obstruction)
        :param vuln_edges_gdf: GeoDataFrame of the edges that form the shortest path (with obstruction)
        :param resilience_index: A measure of the increase in the time to the shortest path due to the obstruction
        :param deactivation_square: The set of grid squares that caused this obstruction
        :return: dictionary structure of the results
        """
        results = {'base': [base_nodes_gdf, base_edges_gdf],
                   'least_resilient': [vuln_nodes_gdf, vuln_edges_gdf],
                   'resilience_index': resilience_index,
                   'grid_reference': deactivation_square}

        return results

    def generate_square_grid(self, dimension_km: float) -> gpd.GeoDataFrame:
        """
        Generates a square grid covering the total bounds of the edges of the road graph
        :param dimension_km: Dimension (width and height) of the square
        :return: GeoDataframe object containing the squares that form the grid
        """
        edges = self.graph.edges
        bounds = list(edges.total_bounds)
        minx, miny, maxx, maxy = bounds[0], bounds[1], bounds[2], bounds[3]
        size_m = dimension_km * 1000
        y = miny
        gdf = gpd.GeoDataFrame()

        list_of_poly = {'id': [], 'geometry': []}
        id = 1
        while y < maxy:
            x = minx
            while x < maxx:
                coordinates = [(x, y), (x, y + size_m), (x + size_m, y + size_m), (x + size_m, y)]
                list_of_poly['id'].append(id)
                list_of_poly['geometry'].append(Polygon(coordinates))
                id += 1

                x += size_m
            y += size_m

        df = pd.DataFrame(list_of_poly)
        gdf = gpd.GeoDataFrame(df, geometry='geometry')
        gdf.crs = {'init': 'epsg:27700'}

        return gdf

    def filter_grid_by_nodes(self, grid: gpd.GeoDataFrame, nodes: gpd.GeoDataFrame = None) -> gpd.GeoDataFrame:
        """
        Removes squares from the grid that does not contain any nodes
        :param grid: Grid GeoDataFrame
        :param nodes: nodes geodataframe, is left as None then stdRoadGraph's nodes will be used instead.
        :return: Grid GeoDataFrame with only squares that contain nodes
        """

        if nodes is None:
            nodes = self.graph.nodes[STD_GEOMETRY].tolist()
        else:
            nodes = nodes[STD_GEOMETRY].tolist()

        contains_node = grid[STD_GEOMETRY].apply(lambda x: any(x.intersects(node) for node in nodes))
        grid.drop(index=contains_node[contains_node == False].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def filter_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes key site points that are not within the bounds of grid
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: key_sites GeoDataFrame with only points residing within the grid
        """
        squares = grid[STD_GEOMETRY].tolist()
        within_square = key_sites[STD_GEOMETRY].apply(lambda x: any(x.within(square) for square in squares))
        key_sites.drop(index=within_square[within_square == False].index, inplace=True)
        key_sites.reset_index(drop=True, inplace=True)
        return key_sites

    def filter_grid_by_key_sites(self, grid: gpd.GeoDataFrame, key_sites: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Removes squares of the grid that contains a key site
        :param grid: grid Polygon (square) GeoDataFrame
        :param key_sites: Points GeoDataFrame of key sites
        :return: grids geoDataFrame that do not have any key site points contained within it
        """
        key_sites = key_sites[STD_GEOMETRY].tolist()
        contains_key_site = grid[STD_GEOMETRY].apply(lambda x: any(x.contains(key_site) for key_site in key_sites))
        grid.drop(index=contains_key_site[contains_key_site == True].index, inplace=True)
        grid.reset_index(drop=True, inplace=True)
        return grid

    def _nearest_nodes_each_site(self, key_sites: gpd.GeoDataFrame, key_col_name: str, nodes: gpd.GeoDataFrame):
        """
        Creates dictionary of nearest nodes for each key site
        :param key_sites: Geo Data Frame of key sites
        :param key_col_name: Column name of key sites
        :param nodes: Nodes Geo Data Frame.
        :return: Dictionary of 100 closest nodes to each site (furthest to closest).
        """
        node_points = nodes.loc[:, STD_GEOMETRY]
        key_sites['nearest_nodes'] = key_sites[STD_GEOMETRY].apply(lambda x: self._sort_nearest_node(x, node_points))
        key_sites_new_index = key_sites.set_index(key_col_name)
        nearest_nodes_df = key_sites_new_index[['nearest_nodes']]

        key_sites.drop(['nearest_nodes'], axis=1, inplace=True)

        return nearest_nodes_df.T.to_dict()

    def _sort_nearest_node(self, point: Point, nodes: gpd.GeoSeries) -> list:
        """
        Calculates and returns the closest 100 nodes to point
        :param point: target point
        :param nodes: Series of candidate nodes
        :return: List of 100 closest nodes to point (from furthest to closest).
        """
        sorted_points = sorted([(point.distance(node), index) for node, index in zip(nodes, nodes.index)], reverse=True)
        sorted_index = [sorted_point[1] for sorted_point in sorted_points]
        return self.graph.nodes.loc[sorted_index[-100:], STD_NODE_ID].tolist()

    def _nearest_node(self, point: Point, nodes: gpd.GeoSeries) -> str:
        """
        Returns the nearest node to point
        :param point: point as Shapely.Point
        :return: Node Id of nearest node
        """
        closest_point = min([(point.distance(node), index) for node, index in zip(nodes, nodes.index)])
        return self.graph.nodes.loc[closest_point[1], STD_NODE_ID]

    def assign_key_sites_to_nearest_nodes(self, key_sites: gpd.GeoDataFrame, nodes: gpd.GeoDataFrame) \
            -> gpd.GeoDataFrame:
        """
        Sets up new column in key_site GeoDataFrame stipulating the nearest node at each key site
        :param nodes: GeoDataframe of available nodes
        :param key_sites: GeoDataFrame of the key sites.
        :return: Updated key sites containing the nearest node per key site.
        """
        node_points = nodes.loc[:, STD_GEOMETRY]

        key_sites[NEAREST_NODE] = key_sites[STD_GEOMETRY].apply(lambda x: self._nearest_node(x, node_points))

        for index, key_site in key_sites.iterrows():
            nearest_node_id = key_site[NEAREST_NODE]
            key_sites.loc[key_sites[NEAREST_NODE] == nearest_node_id, STD_GEOMETRY] = \
                self.graph.nodes.loc[self.graph.nodes[STD_NODE_ID] == nearest_node_id, STD_GEOMETRY].values[0]

        return key_sites

    def deactivate_edges_between_nodes(self, nodes_within_grid: list, only_srn: bool = False):
        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                if only_srn:
                    if self.graph.net[node][neighbour][STD_Nx_ATTR][STD_Nx_IS_SRN]:
                        self.graph.set_road_closure(node, neighbour)
                        self.graph.set_road_closure(neighbour, node)
                else:
                    self.graph.set_road_closure(node, neighbour)
                    self.graph.set_road_closure(neighbour, node)

    def activate_edges_between_nodes(self, nodes_within_grid: list):

        for node in nodes_within_grid:
            neighbours = list(self.graph.net.successors(node))
            for neighbour in neighbours:
                self.graph.remove_road_closure(node, neighbour)
                self.graph.remove_road_closure(neighbour, node)
